shopt -s extglob

if [ $(uname) == Darwin ]; then
    sed() { command sed -l "$@"; }
else
    sed() { command sed -u "$@"; }
fi

# Syntax sugar.
indent() {
  sed "s/^/       /"
}

# Clean up pip output
cleanup() {
  sed -e 's/\.\.\.\+/.../g' | sed -e '/already satisfied/Id' | sed -e '/Overwriting/Id' | sed -e '/python executable/Id' | sed -e '/no previously-included files/Id'
}

# Buildpack Indented line.
puts-line() {
  echo "       $@"
}

# Buildpack Steps.
puts-step() {
  echo "-----> $@"
}

# Buildpack Warnings.
puts-warn() {
  echo " !     $@"
}

# Buildpack Commands.
puts-cmd() {
  echo "     $ $@"
}

# Usage: $ set-env key value
set-env() {
  echo "export $1=$2" >> $PROFILE_PATH
}

# Usage: $ set-default-env key value
set-default-env() {
  echo "export $1=\${$1:-$2}" >> $PROFILE_PATH
}

# Usage: $ un-set-env key
un-set-env() {
  echo "unset $1" >> $PROFILE_PATH
}

# Does some serious copying.
deep-cp() {
  declare source="$1" target="$2"

  mkdir -p "$target"

  # cp doesn't like being called without source params,
  # so make sure they expand to something first.
  # subshell to avoid surprising caller with shopts.
  (
    shopt -s nullglob dotglob
    set -- "$source"/!(tmp|.|..)
    [[ $# == 0 ]] || cp -a "$@" "$target"
  )
}

# Does some serious moving.
deep-mv() {
  deep-cp "$1" "$2"
  deep-rm "$1"
}

# Does some serious deleting.
deep-rm() {
  # subshell to avoid surprising caller with shopts.
  (
    shopt -s dotglob
    rm -rf "$1"/!(.curlrc|.netrc|tmp|.|..)
  )
}

download-unpack() {
  URL="$1"
  FILENAME="${URL##*/}"
  TARGET_DIR="$2"

  TMP_DOWNLOAD_DIR=$(mktemp -d)
  trap "rm -rf $TMP_DOWNLOAD_DIR" RETURN

  WORKING_DIR="$PWD"
  cd $TMP_DOWNLOAD_DIR

  curl $URL --silent --fail --retry 5 --retry-max-time 15 -o $FILENAME || return 1

  grep -s -e "  $FILENAME\$" $CHECKSUMS_FILE | sha256sum --check --strict > /dev/null 2>&1

  # Both statuses have to be assigned in one command, or PIPESTATUS will be overwritten.
  GREP_STATUS="${PIPESTATUS[0]}" SHASUM_STATUS="${PIPESTATUS[1]}"

  if [[ $GREP_STATUS != 0 ]] ; then
    # TODO: Make this fatal in the future, once we're confident no checksums are missing.
    puts-warn "Skipping verification of $FILENAME - no known checksum found!"
  elif [[ $SHASUM_STATUS != 0 ]] ; then
    puts-warn "Downloaded file $FILENAME did not have the expected checksum. Aborting!"
    exit 1
  fi

  cd $WORKING_DIR
  tar xzf $TMP_DOWNLOAD_DIR/$FILENAME -C $TARGET_DIR &> /dev/null
}

sub-env() {

  WHITELIST=${2:-''}
  BLACKLIST=${3:-'^(GIT_DIR|PYTHONHOME|LD_LIBRARY_PATH|LIBRARY_PATH|PATH)$'}

  # Python-specific variables.
  export PYHONHOME=$BUILD_DIR/.heroku/python
  export PYTHONPATH=$BUILD_DIR/

  (
    if [ -d "$ENV_DIR" ]; then
      for e in $(ls $ENV_DIR); do
        echo "$e" | grep -E "$WHITELIST" | grep -qvE "$BLACKLIST" &&
        export "$e=$(cat $ENV_DIR/$e)"
        :
      done
    fi

    $1

  )
}

