#!/usr/bin/env bash

# fail hard
set -o pipefail
# fail harder
set -eu

OUT_PREFIX=$1
BIN_DIR="$(cd "$(dirname "$0")"/../.. || exit; pwd)/bin"
export BIN_DIR

# Orient ourselves and build download link
dep_formula=${0#$WORKSPACE_DIR/} # this is the original script, e.g. pypy-5.3.1
BASE=${dep_formula##*/} # this gives us relative path
python_version=${BASE^} # this gives us only the filename with version number
version_number=$(echo "$python_version" | cut -d- -f2) # this returns just X.X.X
dep_url=https://python.org/ftp/python/${version_number}/${python_version}.tgz

# Install SQLITE, as headers are not available out of the box on the stack
apt-get install libsqlite3-dev
needed=( libsqlite3-dev )
if [[ $STACK != "heroku-16" && $STACK != "heroku-16" ]]; then
	needed+=( realpath )

# Check whether our packages are missing on the stack
missing=$(comm -1 -3 <(dpkg-query -W -f '${package}\n' | sort) <(IFS=$'\n'; echo "${needed[*]}" | sort))
if [[ "$missing" ]]; then
    # install missing and needed packages
	apt-get update -qq || { echo "Failed to 'apt-get update'. You must build this formula using Docker."; exit 1; }
	apt-get install -q -y $missing
fi

curl -L "${dep_url}" | tar xz -C "${OUT_PREFIX}"
mv "${OUT_PREFIX}/${python_version}" src
cd src

./configure --prefix=$OUT_PREFIX --with-ensurepip=no
make
make install

# Remove unneeded test directories, similar to the official Docker Python images:
# https://github.com/docker-library/python
find "${OUT_PREFIX}" \( -type d -a \( -name test -o -name tests \) \) -exec rm -rf '{}' +

# Remove spare /
LOCATION=${OUT_PREFIX%?}

# Create links to SQLITE headers so Python can call them at runtime
mkdir -p ${OUT_PREFIX}/include ${OUT_PREFIX}/lib/x86_64-linux-gnu
cp /usr/include/sqlite3*.h ${OUT_PREFIX}/include
ln -fs $(realpath /usr/lib/x86_64-linux-gnu/libsqlite3.so) ${OUT_PREFIX}/lib/x86_64-linux-gnu/libsqlite3.so

ln $LOCATION/bin/python3 $LOCATION/bin/python
